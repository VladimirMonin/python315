"""

- Понятие родительского класса и дочернего класса
- Когда наследование имеет смысл?
- Синтаксис наследования
- Наследование без явного указания инициализатора родительского класса
- Переопределение методов и атрибутов родительского класса
- Работа с инициализатором и явное указание инициализатора родительского класса
- Super - вызов методов родительского класса
- Практика
- Решение практики
- Цепочка наследования
- Переопределение методов
- Повторение материала
- Множественное наследование
- Многоуровневое наследование
- MRO
- `.mro()`
- `isinstance()` и `issubclass()`
- Разрешение конфликтов
- Абстрактные классы
- Миксины
- Инициализация и при наследовании
"""

# Понятие родительского класса и дочернего класса
"""
Родительский класс (суперкласс) - класс, от которого наследуются свойства и методы
Дочерний класс (подкласс) - класс, который наследует свойства и методы родительского класса
"""


class Animal:
    def __init__(self, name='Бобик'):
        self.name = name
        self.age = 0

    def speak(self):
        print(f"Меня зовут {self.name}.")

    def __str__(self):
        return f'Animal: {self.name}, {self.age} лет'


class Dog(Animal):
    def speak(self):
        print(f"Меня зовут {self.name}, и я собака. Woof!")


class Cat(Animal):
    def speak(self):
        print(f"Меня зовут {self.name}, и я кошка. Meow!")


class Bird(Animal):
    def speak(self):
        print(f"Меня зовут {self.name}, и я птица. Chirp!")


dog = Dog()
cat = Cat('Мурзик')
bird = Bird('Чижик')

"""
Полиморфизм - это способность объектов с одинаковым интерфейсом иметь различную реализацию
Мы можем вызвать метод speak у всех объектов, но каждый из них будет вести себя по-разному
Даже логика может быть разной, главное чтобы интерфейс был одинаковым, и ожидался одинаковый результат
"""

dog.speak()
cat.speak()
bird.speak()

animals = [dog, cat, bird]

for animal in animals:
    animal.speak()

[animal.speak() for animal in animals]

