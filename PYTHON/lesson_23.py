"""

- Понятие родительского класса и дочернего класса
- Когда наследование имеет смысл?
- Синтаксис наследования
- Наследование без явного указания инициализатора родительского класса
- Переопределение методов и атрибутов родительского класса
- Работа с инициализатором и явное указание инициализатора родительского класса
- Super - вызов методов родительского класса
- Практика
- Решение практики
- Цепочка наследования
- Переопределение методов
- Повторение материала
- Множественное наследование
- Многоуровневое наследование
- MRO
- `.mro()`
- `isinstance()` и `issubclass()`
- Разрешение конфликтов
- Абстрактные классы
- Миксины
- Инициализация и при наследовании
"""


# Понятие родительского класса и дочернего класса

"""
Мы можем переопределить методы родительского класса в дочернем классе
Но при этом мы можем и расширить функционал родительского метода, в дочернем, добавив новую логику.
"""


class Animal:
    def __init__(self, name='Бобик', age=0, puws=0):
        self.name = name
        self.age = 0
        self.puws = 0

    def speak(self, type_of_animal='животное'):
        print(f"В первую очередь я {__class__.__name__}, а потом {type_of_animal}")

    def __str__(self):
        return f'Animal: {self.name}, {self.age} лет'


class Dog(Animal):
    def speak(self):
        print(f"Меня зовут {self.name}, и я собака. Woof!")


class Cat(Animal):
    """
    Расширим атрибуты у кота, добавим пушистость
    С вызовом инициализатора родительского класса
    """

    def __init__(self, name, fluffiness, age, puws):
        super().__init__(name, age, puws)
        self.fluffiness = fluffiness

    def speak(self):
        # вызов метода родительского класса
        class_name = self.__class__.__name__
        super().speak(class_name)
        print(f"Меня зовут {self.name}, и я кот. Meow!")


class Bird(Animal):
    def speak(self):
        print(f"Меня зовут {self.name}, и я птица. Chirp!")


# animal = Animal()
# animal.speak()

cat = Cat('Барсик', 5, 2, 3)
cat.speak()
